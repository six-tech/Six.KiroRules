---
inclusion: fileMatch
fileMatchPattern: ['*.sln', '*.slnx', 'global.json', './Directory.Build.props', 'apps/Directory.Build.props', 'libs/Directory.Build.props', 'libs/Directory.Build.targets', 'tests/Directory.Build.props', 'tests/Directory.Build.targets', 'benchmarks/Directory.Build.props', 'libs/*.csproj', 'libs/*.fsproj']
---

# Cursor Rules File: Best Practices for .NET Solution Management based on Six.SolutionTemplate

**Role Definition:**
- .NET Solution Architect
- Build System Expert
- Package Management Specialist

# IMPORTANT SECURITY RULES:
- you have no power or authority to make any database changes
- only the User himself can make DB changes, whether Dev or Prod
- if you want to make any Database-related change, suggest it first to the User
- NEVER EVER attempt to run any DB migrations, or make any database changes. this is strictly prohibited.
- NEVER EVER place sensitive information in the generated code (e.g. passwords, API keys, personal information, etc.)


## General

### Description
.NET solutions must be configured with explicit SDK versioning, shared build properties,
and secure package sources to ensure consistency, maintainability, and security
across all projects within the solution.

Uses [Six.SolutionTemplate](https://github.com/six-tech/Six.SolutionTemplate) a GitHub template for .NET solutions. 

**Six.SolutionTemplate** provides a solid foundation for maintainable .NET solutions with consistent SDK versions, shared metadata, AI
IDEs integration (Cursor and Kiro), embedded documentation using `Astro.js` and `Starlight`, and more.

Full documentation: [Six.SolutionTemplate](https://six-tech.github.io/Six.SolutionTemplate/)


### Requirements

- Maintain a `global.json` for SDK version control
- Maintain master `Directory.Build.props` in solution root for common build properties
- Use master `Directory.Build.props` in solution root when dealing with `libs/Directory.Build.props`, `apps/Directory.Build.props`, `tests/Directory.
Build.props`, and `benchmarks/Directory.Build.props` 
- Configure secure and reliable package sources in `nuget.config`
- Write and maintain AGENTS.md for AI agents using `.cursor/rules/documentation/agents-md.mdc` rules
- Write and maintain README.md docs `.cursor/rules/documentation/readme-md.mdc` rules
- Prefer `.slnx` format over traditional `.sln`


## Solution Structure

> [!IMPORTANT]
> 
> **DO NOT create new files without first checking existing ones**. Build system files should follow a consistent,
predictable structure.

### File Structure and Hierarchy
> [!IMPORTANT]
> - Required files and directories have an annotation (Required).
> - Each file and directory has a brief description for what it is used for.

```
├── Directory.Build.props                             # (Required) Master Directory.Build.props from which all other Directory.Build.props inherit.
├── global.json                                       # (Required) SDK version pinning
├── README.md                                         # (Required) Markdown file containing brief docs about the repository
├── RELEASE_NOTES.md                                  # (Required) Autogenerated release notes markdown (generated with release-notes.cs script)
├── LICENSE.md                                        # (Required) License file in markdown format
├── AGENTS.md                                         # (Required) [Agents.md](https://agents.md/) - repository documentation for AI agents
├── build.cs                                          # (Required) Version management script (minimal)
├── .cursor/rules/                                    # Cursor rules from [Six.CursorRules](https://github.com/six-tech/Six.CursorRules)
├── .kiro/                                            # Kiro configuration (agentic IDE that helps you do your best work with features such as specs, steering, and hooks) [Kiro](https://kiro.dev/docs/getting-started/)
├── .github/workflows/                                # GitHub Actions (if used)
│   ├── pr-validation.yaml                            # PR validation workflow (restore, build, and perform tests)
│   ├── release.yaml                                  # Release workflow
│   └── *.yaml                                        # Other GitHub workflows
├── scripts/                                          # C# single file app helper scripts (needs .NET 10 installed)
│   ├── release-notes.cs                              # Script to generate release notes
│   ├── bump-version.cs                               # Script to bump version in the MASTER ./Directory.Build.props file
│   ├── tests-integration.cs                          # Script to run integration tests
│   ├── nuget-pack.cs                                 # Script to pack and publish NuGet packages
│   └── *.cs                                          # Other helper c# scripts
├── apps/                                             # Directories with all c# applications in the repository (Web, Console, Avalonia applications, etc.)
│   ├── Directory.Build.props                         # (Required) Directory.Build.props for apps (inherits from root Directory.Build.props)
│   ├── Some.AppA/                                    # Example application (here just for this structure example)
│   │   ├── src/                                      # Source files for the application
│   │   ├── project_icon.png                          # Project icon (bundled with the application)
│   │   ├── README.md                                 # Readme markdown file with brief docs about the application
│   │   ├── GlobalUsings.cs                           # Global usings file for the application with most common namespaces
│   │   └── Some.AppA.csproj                          # Example application project file
│   ├── Some.AppB/                                    # Example application (here just for this structure example)
│   │    ├── src/                                     # Source files for the application
│   │    ├── project_icon.png                         # Project icon (bundled with the application)
│   │    ├── README.md                                # Readme markdown file with brief docs about the application
│   │    ├── GlobalUsings.cs                          # Global usings file for the application with most common namespaces
│   │    └── Some.AppB.csproj                         # Example application project file
│   └── ...other application projects                 # More applications in `apps/` directory
├── libs/                                             # (Required) Directories with all c# libraries in the repository (.csprojes with type `library` than can be packed as NuGet packages)
│   ├── Directory.Build.props                         # (Required) Directory.Build.props for libraries (inherits from root Directory.Build.props)
│   ├── Directory.Build.targets                       # (Required) Directory.Build.targets just for libraries
│   ├── Some.LibraryA/                                # Example library (here just for this structure example)
│   │   ├── src/                                      # Source files for the library
│   │   ├── project_icon.png                          # Project icon (bundled with the package)
│   │   ├── README.md                                 # Readme markdown file with brief docs about the library
│   │   ├── GlobalUsings.cs                           # Global usings file for the library with most common namespaces
│   │   └── Some.LibraryA.csproj                      # Example library project file
│   ├── Some.LibraryB/                                # Example library (here just for this structure example)
│   │    ├── src/                                     # Source files for the library
│   │    ├── project_icon.png                         # Project icon (bundled with the package)
│   │    ├── README.md                                # Readme markdown file with brief docs about the library
│   │    ├── GlobalUsings.cs                          # Global usings file for the library with most common namespaces
│   │    └── Some.LibraryB.csproj                     # Example library project file
│   └── ...other library projects                     # More libraries in `libs/` directory
├── tests/                                            # Directories with all test projects in the repository
│   ├── Directory.Build.props                         # (Required) Directory.Build.props for tests (inherits from root Directory.Build.props)
│   ├── Directory.Build.targets                       # (Required) Central version and package metadata
│   ├── Some.LibraryA.Test.Unit/                      # Example test (here just for this structure example)
│   │   ├── src/                                      # Source files for the test
│   │   ├── README.md                                 # Readme markdown file with brief docs about the test
│   │   ├── GlobalUsings.cs                           # Global usings file for the test with most common namespaces
│   │   └── Some.LibraryA.Test.Unit.csproj            # Example test project file
│   ├── Some.LibraryB.Test.Integration/               # Example test (here just for this structure example)
│   │    ├── src/                                     # Source files for the test
│   │    ├── README.md                                # Readme markdown file with brief docs about the test
│   │    ├── GlobalUsings.cs                          # Global usings file for the test with most common namespaces
│   │    └── Some.LibraryB.Test.Integration.csproj    # Example test project file
│   └── ...other test projects                        # More tests in `tests/` directory
├── benchmarks/                                       # Directories with all benchmark projects in the repository
│   ├── Directory.Build.props                         # (Required) Directory.Build.props for benchmarks (inherits from root Directory.Build.props)
│   ├── Some.LibraryA.Benchmark/                      # Example benchmark (here just for this structure example)
│   │   ├── src/                                      # Source files for the benchmark
│   │   ├── README.md                                 # Readme markdown file with brief docs about the benchmark
│   │   ├── GlobalUsings.cs                           # Global usings file for the benchmark with most common namespaces
│   │   └── Some.Library.A.csproj                     # Example benchmark project file
│   ├── Some.LibraryB.Benchmark/                      # Example benchmark (here just for this structure example)
│   │    ├── src/                                     # Source files for the benchmark
│   │    ├── README.md                                # Readme markdown file with brief docs about the benchmark
│   │    ├── GlobalUsings.cs                          # Global usings file for the benchmark with most common namespaces
│   │    └── Some.Library.B.csproj                    # Example benchmark project file
│   └── ...other benchmark projects                   # More benchmarks in `benchmarks/` directory
└── docs/                                             # Repository documentation (astro.js/starlight)
    ├── astro.config                                  # Standard Astro.js/Starlight configuration.
    └── src/                                          
        └── content/                                  
            └── docs/                                 # Directory where all documentation pages are located

```

### File Responsibilities

#### Master Directory.Build.props in the Solution Root Directory

- This is a **MASTER** `Directory.Build.props` file from which all other `Directory.Build.props` files inherit.
- Common build properties for all projects in the solution
- Stylecop configuration
- TreatWarningsAsErrors configuration

Example:

```xml
<!-- MASTER Directory.Build.props -->
<!-- All other Directory.Build.props files inherit from this one -->
<Project>
    <PropertyGroup>
        <LangVersion>13</LangVersion>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>

        <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
        <NoWarn>CS1591,CS0649,CS0169,CA1050,CA1822,CA2211,IDE1006,CS1574,CS1584,CS1581,CS1580,NU5104</NoWarn>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="JetBrains.Annotations" Version="2025.2.0"/>
    </ItemGroup>

    <PropertyGroup>
        <CodeAnalysisRuleSet>$(MSBuildThisFileDirectory).ruleset</CodeAnalysisRuleSet>
        <StyleCopTreatErrorsAsWarnings>false</StyleCopTreatErrorsAsWarnings>
        <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
        <AnalysisLevel>preview</AnalysisLevel>
    </PropertyGroup>

    <ItemGroup>
        <AdditionalFiles Include="$(MSBuildThisFileDirectory)stylecop.json" Link="stylecop.json"/>
    </ItemGroup>

</Project>
```

#### Directory.Build.props in apps/ Directory

- Inherits from the master Directory.Build.props in solution root
- Configures properties specific to application projects
- Sets up application-specific package references and configurations
- Defines output type and other application-related settings

Example:

```xml
<!-- apps/Directory.Build.props -->
<!-- Inherits from master Directory.Build.props -->
<Project>
    <Import Project="$(MSBuildThisFileDirectory)../Directory.Build.props" />
    
    <PropertyGroup>
        <!-- Application-specific properties -->
        <OutputType>Exe</OutputType>
        <UseAppHost>true</UseAppHost>
        <SelfContained>false</SelfContained>
        
        <!-- Application metadata -->
        <Product>$(AssemblyName)</Product>
        <Description>Application built with Six.SolutionTemplate</Description>
        
        <!-- Application-specific warnings to suppress -->
        <NoWarn>$(NoWarn);CA1014;CA2007</NoWarn>
    </PropertyGroup>

    <ItemGroup>
        <!-- Common application dependencies -->
        <PackageReference Include="Microsoft.Extensions.Hosting" Version="10.0.0" />
        <PackageReference Include="Microsoft.Extensions.Configuration" Version="10.0.0" />
        <PackageReference Include="Microsoft.Extensions.Logging" Version="10.0.0" />
    </ItemGroup>
</Project>
```

#### Directory.Build.props in libs/ Directory

- Inherits from the master Directory.Build.props in solution root
- Configures properties specific to library projects that can be packed as NuGet packages
- Sets up packaging metadata and library-specific configurations
- Defines common dependencies for libraries

Example:

```xml
<!-- libs/Directory.Build.props -->
<!-- Inherits from master Directory.Build.props -->
<Project>
    <Import Project="$(MSBuildThisFileDirectory)../Directory.Build.props" />
    
    <PropertyGroup>
        <!-- Library-specific properties -->
        <GeneratePackageOnBuild>false</GeneratePackageOnBuild>
        <IsPackable>true</IsPackable>
        <IncludeSymbols>true</IncludeSymbols>
        <SymbolPackageFormat>snupkg</SymbolPackageFormat>
        
        <!-- Package metadata -->
        <PackageReadmeFile>README.md</PackageReadmeFile>
        <PackageIcon>package_icon.png</PackageIcon>
        <PackageRequireLicenseAcceptance>false</PackageRequireLicenseAcceptance>
        <PackageTags>dotnet;library;six</PackageTags>
        
        <!-- Source Link for debugging -->
        <PublishRepositoryUrl>true</PublishRepositoryUrl>
        <EmbedUntrackedSources>true</EmbedUntrackedSources>
        <IncludeSourceRevisionInInformationalVersion>true</IncludeSourceRevisionInInformationalVersion>
    </PropertyGroup>

    <ItemGroup>
        <!-- Package files -->
        <None Include="README.md" Pack="true" PackagePath="\"/>
        <None Include="package_icon.png" Pack="true" PackagePath="\"/>
        
        <!-- Source Link -->
        <PackageReference Include="Microsoft.SourceLink.GitHub" Version="10.0.0" PrivateAssets="All"/>
    </ItemGroup>
</Project>
```

#### Directory.Build.props in tests/ Directory

- Inherits from the master Directory.Build.props in solution root  
- Configures properties specific to test projects
- Sets up testing frameworks and test-specific configurations
- Defines common test dependencies

Example:

```xml
<!-- tests/Directory.Build.props -->
<!-- Inherits from master Directory.Build.props -->
<Project>
    <Import Project="$(MSBuildThisFileDirectory)../Directory.Build.props" />
    
    <PropertyGroup>
        <!-- Test-specific properties -->
        <IsPackable>false</IsPackable>
        <IsTestProject>true</IsTestProject>
        
        <!-- Test configuration -->
        <CollectCoverage>true</CollectCoverage>
        <CoverletOutputFormat>cobertura</CoverletOutputFormat>
        <CoverletOutput>$(MSBuildProjectDirectory)/coverage/</CoverletOutput>
        <Threshold>80</Threshold>
        <ThresholdType>line</ThresholdType>
        <ThresholdStat>total</ThresholdStat>
        
        <!-- Test-specific warnings to suppress -->
        <NoWarn>$(NoWarn);CA1707;CA1062;CA2007</NoWarn>
    </PropertyGroup>

    <ItemGroup>
        <!-- Common test framework packages -->
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.12.0" />
        <PackageReference Include="xunit" Version="2.9.3" />
        <PackageReference Include="xunit.runner.visualstudio" Version="3.0.0" />
        <PackageReference Include="FluentAssertions" Version="7.0.0" />
        <PackageReference Include="AutoFixture" Version="5.0.0" />
        <PackageReference Include="Moq" Version="4.20.72" />
        
        <!-- Code coverage -->
        <PackageReference Include="coverlet.collector" Version="6.0.3" />
        <PackageReference Include="coverlet.msbuild" Version="6.0.3" />
    </ItemGroup>
</Project>
```

#### Directory.Build.props in benchmarks/ Directory

- Inherits from the master Directory.Build.props in solution root
- Configures properties specific to benchmark projects  
- Sets up BenchmarkDotNet and performance testing configurations
- Defines benchmark-specific optimizations

Example:

```xml
<!-- benchmarks/Directory.Build.props -->
<!-- Inherits from master Directory.Build.props -->
<Project>
    <Import Project="$(MSBuildThisFileDirectory)../Directory.Build.props" />
    
    <PropertyGroup>
        <!-- Benchmark-specific properties -->
        <IsPackable>false</IsPackable>
        <OutputType>Exe</OutputType>
        
        <!-- Performance optimizations -->
        <Optimize>true</Optimize>
        <DebugType>pdbonly</DebugType>
        <DebugSymbols>true</DebugSymbols>
        
        <!-- Benchmark configuration -->
        <ServerGarbageCollection>true</ServerGarbageCollection>
        <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>
        
        <!-- Benchmark-specific warnings to suppress -->
        <NoWarn>$(NoWarn);CA1822;CA1806</NoWarn>
    </PropertyGroup>

    <ItemGroup>
        <!-- BenchmarkDotNet packages -->
        <PackageReference Include="BenchmarkDotNet" Version="0.14.0" />
        <PackageReference Include="BenchmarkDotNet.Diagnostics.Windows" Version="0.14.0" Condition="'$(OS)' == 'Windows_NT'" />
    </ItemGroup>
</Project>
```



## SDK Version Management

### global.json Configuration

Maintain a `global.json` file in the solution root to ensure consistent builds across all environments:

> [!IMPORTANT]
> 
> Without explicit SDK versioning, different developers and CI environments might use different .NET SDK versions, leading to inconsistent build results, unexpected breaking changes, or hard-to-reproduce issues.

#### Recommended Configuration

```json
{
  "sdk": {
    "version": "10.0.100-preview.7",
    "rollForward": "patch",
    "allowPrerelease": true
  }
}
```

#### SDK Update Strategy

1. **Regular Updates**: Update SDK versions quarterly or when security patches are released
2. **Testing Process**: 
   - Test new SDK versions in a feature branch first
   - Run full test suite and verify builds work correctly
   - Update CI/CD pipeline configurations if needed
3. **Documentation**: Always document SDK version changes in commit messages and release notes
4. **Rollback Plan**: Keep previous working SDK version documented for quick rollback if issues arise

#### Example Update Workflow

```bash
# 1. Check current SDK version
dotnet --version

# 2. Update global.json to new SDK version
# Edit global.json with new version

# 3. Test the build
dotnet clean
dotnet restore
dotnet build --configuration Release

# 4. Run tests
dotnet test --configuration Release --no-build

# 5. Commit changes with clear message
git add global.json
git commit -m "chore: update .NET SDK to 10.0.100-preview.8

- Updated from 10.0.100-preview.7 to 10.0.100-preview.8
- Tested builds and tests pass
- No breaking changes affecting current codebase"
```

## Shared Build Properties

### Master Directory.Build.props Strategy

The **master Directory.Build.props** serves as the foundation for all build configurations across your solution. It should contain properties that apply to **all** projects regardless of type (applications, libraries, tests, benchmarks).

> [!TIP]
> 
> **Inheritance Hierarchy:** Master Directory.Build.props → Subdirectory Directory.Build.props → Individual Project Files
>
> Each level can override or extend properties from the previous level.

### Essential Properties for Master Directory.Build.props

```xml
<Project>
    <!-- Language and Framework Configuration -->
    <PropertyGroup>
        <LangVersion>13</LangVersion>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    </PropertyGroup>

    <!-- Solution-wide Metadata -->
    <PropertyGroup>
        <Authors>Your Company Name</Authors>
        <Company>Your Company Name</Company>
        <Copyright>© $([System.DateTime]::Now.Year) Your Company Name</Copyright>
        <PackageLicenseExpression>MIT</PackageLicenseExpression>
        <PackageProjectUrl>https://github.com/your-org/your-repo</PackageProjectUrl>
        <RepositoryUrl>https://github.com/your-org/your-repo</RepositoryUrl>
        <RepositoryType>git</RepositoryType>
        <VersionPrefix>1.0.0</VersionPrefix>
        <AssemblyVersion>1.0.0</AssemblyVersion>
        <FileVersion>1.0.0</FileVersion>
    </PropertyGroup>

    <!-- Build Quality and Analysis -->
    <PropertyGroup>
        <AnalysisLevel>preview</AnalysisLevel>
        <CodeAnalysisRuleSet>$(MSBuildThisFileDirectory).ruleset</CodeAnalysisRuleSet>
        <StyleCopTreatErrorsAsWarnings>false</StyleCopTreatErrorsAsWarnings>
        <NoWarn>CS1591,CS0649,CS0169,CA1050,CA1822,CA2211,IDE1006,CS1574,CS1584,CS1581,CS1580,NU5104</NoWarn>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="JetBrains.Annotations" Version="2025.2.0"/>
    </ItemGroup>

    <!--        
        StyleCop: https://github.com/DotNetAnalyzers/StyleCopAnalyzers
    -->
    <PropertyGroup>
        <CodeAnalysisRuleSet>$(MSBuildThisFileDirectory).ruleset</CodeAnalysisRuleSet>
        <StyleCopTreatErrorsAsWarnings>false</StyleCopTreatErrorsAsWarnings>
        <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
        <AnalysisLevel>preview</AnalysisLevel>
    </PropertyGroup>

    <ItemGroup>
        <AdditionalFiles Include="$(MSBuildThisFileDirectory)stylecop.json" Link="stylecop.json"/>
    </ItemGroup>

    <!-- Performance and Optimization -->
    <PropertyGroup>
        <Deterministic>true</Deterministic>
        <ContinuousIntegrationBuild Condition="'$(GITHUB_ACTIONS)' == 'true' or '$(TF_BUILD)' == 'true'">true</ContinuousIntegrationBuild>
    </PropertyGroup>

</Project>
```


#### CI/CD Pipeline Integration

```xml
<!-- Example: Azure DevOps or GitHub Actions integration -->
<PropertyGroup>    
    <!-- Enable additional analysis in CI -->
    <RunCodeAnalysis Condition="'$(TF_BUILD)' == 'true' or '$(GITHUB_ACTIONS)' == 'true'">true</RunCodeAnalysis>
    <EnableNETAnalyzers>true</EnableNETAnalyzers>
</PropertyGroup>
```

### Best Practices for Shared Properties

1. **Keep it Minimal**: Only include properties that truly apply to ALL projects
2. **Use Comments**: Document why each property group exists
3. **Version Consistently**: Use MSBuild functions for dynamic versioning
4. **Environment Variables**: Leverage environment variables for CI/CD integration
5. **Override Capability**: Design for easy overrides in subdirectories
6. **Performance**: Consider build performance impact of global analyzers and tools


## Package Management with nuget.config
- Configure and maintain `nuget.config`:
- **DO NOT DELETE** comments from `nuget.config`. They are used to document the configuration. 
- Use environment variables for security
- Support multiple package sources for different environments
- Clear default sources to ensure only configured sources are used

### Example company standard configuration
```xml
  <?xml version="1.0" encoding="utf-8"?>
  <!--
      NuGet Configuration File for Six.SolutionTemplate
    
      This configuration file defines NuGet package sources and credentials for the solution template.
      It supports four publishing scenarios:
      1. Local Feed: Packages published to a local directory that serves as NuGet feed (for testing and similar)
      2. Dev Feed: Packages published to a NuGet feed for development
      3. Staging Feed: Packages published to a staging NuGet feed (pre-release versions and similar)
      4. Production Feed: Packages published to production NuGet feed
    
      IMPORTANT: All values use environment variables. If you change the environment variable names,
      you MUST also update the corresponding variables in build/nuget-pack.cs to maintain compatibility.
    
      IMPORTANT: If you don't need certain feeds (e.g., Local or Staging) and you didn't set environment
      variables for them, you should remove them from this file or compiler will error if environment variables 
      for them are missing/not set.
    
      Environment Variables Required:
      - NUGET_FEED_LOCAL_URL: Path to local directory for development packages
      - NUGET_FEED_DEV_URL: URL of development NuGet feed
      - NUGET_FEED_DEV_USERNAME: Username for development feed authentication
      - NUGET_FEED_DEV_PAT: Personal Access Token for development feed authentication
      - NUGET_FEED_STAGING_URL: URL of staging NuGet feed
      - NUGET_FEED_STAGING_USERNAME: Username for staging feed authentication
      - NUGET_FEED_STAGING_PAT: Personal Access Token for staging feed authentication    
      - NUGET_FEED_PRODUCTION_URL: URL of production NuGet feed (for public packages, typically https://api.nuget.org/v3/index.json)
      - NUGET_FEED_PRODUCTION_USERNAME: Username for production feed authentication
      - NUGET_FEED_PRODUCTION_PAT: Personal Access Token for production feed authentication    
    
      For detailed setup instructions see:
      https://six-tech.github.io/Six.LibraryTemplate/nuget/nuget-secrets/
      https://six-tech.github.io/Six.LibraryTemplate/nuget/nuget-feeds/
  -->

  <configuration>
      <packageSources>
          <!-- Remove default feeds to ensure only configured sources are used -->
          <clear />
        
          <!-- 
              Local Feed (for local testing and similar)
              Environment Variable: NUGET_FEED_LOCAL_URL
              Purpose: Local directory for development and testing packages
              Example: C:\LocalNuGetFeed or /home/user/local-nuget-feed
          -->
          <add key="Local" value="%NUGET_FEED_LOCAL_URL%" />

          <!-- 
              Development Feed
              Environment Variable: NUGET_FEED_DEV_URL
              Purpose: Local directory for development and testing packages
              Example: C:\LocalNuGetFeed or /home/user/local-nuget-feed
          -->
          <add key="Development" value="%NUGET_FEED_DEV_URL%" />

          <!-- 
              Staging Feed
              Environment Variable: NUGET_FEED_STAGING_URL
              Purpose: Private NuGet feed for internal or staging packages
              Example: https://nuget.pkg.github.com/YOUR_GITHUB_NAME/index.json
          -->
          <add key="Staging" value="%NUGET_FEED_STAGING_URL%" />
        
          <!-- 
              Public Feed (Production Releases)
              Environment Variable: NUGET_FEED_PRODUCTION_URL
              Purpose: For example, public NuGet.org feed for production releases
              Example: https://api.nuget.org/v3/index.json            
          -->
          <add key="Production" value="%NUGET_FEED_PRODUCTION_URL%" />

      </packageSources>

      <!-- 
          Package Source Credentials
          API keys and usernames are stored as environment variables for security.
          Never commit actual credentials to source control.
        
          WARNING: If you change these environment variable names, you MUST update
          the corresponding variables in build/nuget-pack.cs to maintain functionality.
      -->
      <packageSourceCredentials>
          <!-- Development Feed Credentials -->
          <Development>
              <add key="Username" value="%NUGET_FEED_DEV_USERNAME%" />
              <add key="ClearTextPassword" value="%NUGET_FEED_DEV_PAT%" />
          </Development>        
        
          <!-- Staging Feed Credentials -->
          <Staging>
              <add key="Username" value="%NUGET_FEED_STAGING_USERNAME%" />
              <add key="ClearTextPassword" value="%NUGET_FEED_STAGING_PAT%" />
          </Staging>
        
          <!-- Production Feed Credentials -->
          <Production>
              <add key="Username" value="%NUGET_FEED_PRODUCTION_USERNAME%" />
              <add key="ClearTextPassword" value="%NUGET_FEED_PRODUCTION_PAT%" />
          </Production>
      </packageSourceCredentials>
  </configuration>
```

> [!IMPORTANT] Security Best Practices for `nuget.config`:
> 
> - Always use environment variables for credentials, never hardcode them
> - Use Personal Access Tokens (PAT) instead of passwords when possible
> - Set appropriate permissions for each feed (read vs. read/write)
> - Regularly rotate credentials and review access permissions
> - Remove unused feeds from the configuration to reduce attack surface



## Build and Compilation Strategy

### Build Command Standards

> [!TIP]
> **Performance Tip:** Always use the .NET CLI for builds in CI/CD pipelines and team environments. IDE builds may have different configurations and cached state that can lead to inconsistent results.

#### Standard Build Commands

```bash
# Development builds
dotnet clean
dotnet restore
dotnet build

# Release builds (for production)
dotnet build --configuration Release --no-restore

# CI/CD builds (deterministic and optimized)
dotnet build --configuration Release --no-restore /p:ContinuousIntegrationBuild=true

# Full clean and rebuild
dotnet clean && dotnet restore && dotnet build --configuration Release
```

#### Advanced Build Options

```bash
# Build with binary logging for troubleshooting
dotnet build -bl:build.binlog --verbosity normal

# Build specific project only
dotnet build src/MyProject/MyProject.csproj --configuration Release

# Build with custom properties
dotnet build /p:Version=1.2.3-beta /p:TreatWarningsAsErrors=false

# Multi-targeting build
dotnet build --framework net8.0 --runtime win-x64
```

### Code Quality and Error Handling

#### Warning and Error Configuration

Configure comprehensive error handling in your master Directory.Build.props:

```xml
<Project>
    <PropertyGroup>
        <!-- Treat warnings as errors for quality enforcement -->
        <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
        <WarningsAsErrors />
        <WarningsNotAsErrors />
        
        <!-- Suppress specific warnings globally (use sparingly) -->
        <NoWarn>CS1591,CS0649,CS0169,CA1050,CA1822,CA2211,IDE1006</NoWarn>
    </PropertyGroup>

    <!-- In DEBUG: Enable all analyzers and set analysis level -->
    <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
        <AnalysisLevel>preview</AnalysisLevel>
        <EnableNETAnalyzers>true</EnableNETAnalyzers>
        <RunAnalyzersDuringLiveAnalysis>true</RunAnalyzersDuringLiveAnalysis>
    </PropertyGroup>
</Project>
```

#### Warning Suppression Best Practices

1. **Fix First**: Always try to fix the underlying issue rather than suppress
2. **Document Why**: If suppression is necessary, document the reason
3. **Scope Narrowly**: Use `#pragma warning disable` at the smallest scope possible
4. **Review Regularly**: Periodically review all suppressions to see if they're still needed

```csharp
// Good: Narrow scope with explanation
#pragma warning disable CA1062 // Validate arguments of public methods
public void ProcessData(string data)
{
    // Suppressed because data is validated by calling method's contract
    var processed = data.ToUpper();
#pragma warning restore CA1062
}

// Bad: Broad suppression without explanation
#pragma warning disable CA1062
```

### Build Performance Optimization

#### Incremental Builds

```xml
<PropertyGroup>
    <!-- Enable fast up-to-date check for better IDE performance -->
    <DisableFastUpToDateCheck>false</DisableFastUpToDateCheck>
    
    <!-- Enable incremental builds -->
    <UseSharedCompilation>true</UseSharedCompilation>
    <BuildInParallel>true</BuildInParallel>
    
    <!-- Optimize for local development -->
    <UseCommonOutputDirectory>true</UseCommonOutputDirectory>
</PropertyGroup>
```

#### CI/CD Build Optimization

```xml
<PropertyGroup>
    <!-- CI-specific optimizations -->
    <ContinuousIntegrationBuild Condition="'$(CI)' == 'true' or '$(GITHUB_ACTIONS)' == 'true' or '$(TF_BUILD)' == 'true'">true</ContinuousIntegrationBuild>
    
    <!-- Deterministic builds for reproducibility -->
    <Deterministic>true</Deterministic>
    <DeterministicSourcePaths>true</DeterministicSourcePaths>
    
    <!-- Disable features not needed in CI -->
    <UseSharedCompilation>false</UseSharedCompilation>
    <DisableImplicitNuGetFallbackFolder>true</DisableImplicitNuGetFallbackFolder>
</PropertyGroup>
```

### Troubleshooting Build Issues

#### Binary Logging

Enable detailed logging for complex build issues:

```bash
# Generate detailed build log
dotnet build -bl:build.binlog --verbosity diagnostic

# View the log with MSBuild Structured Log Viewer
# Download from: https://msbuildlog.com/
```

#### Common Build Problems and Solutions

1. **Package Version Conflicts**
   ```bash
   # Diagnose package conflicts
   dotnet list package --include-transitive
   dotnet list package --vulnerable
   dotnet list package --deprecated
   ```

2. **Assembly Loading Issues**
   ```xml
   <!-- Add assembly binding redirects if needed -->
   <PropertyGroup>
     <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
     <GenerateBindingRedirectsOutputType>true</GenerateBindingRedirectsOutputType>
   </PropertyGroup>
   ```

3. **Multi-Targeting Issues**
   ```xml
   <!-- Handle framework-specific code -->
   <PropertyGroup>
     <DefineConstants Condition="'$(TargetFramework)' == 'net8.0'">$(DefineConstants);NET8_0_OR_GREATER</DefineConstants>
   </PropertyGroup>
   ```


# End of Cursor Rules File 